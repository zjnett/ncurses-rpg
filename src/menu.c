#include "game/menu.h"

extern menu_option menu_options[100];
extern int num_main_menu_options;

menu_option character_creation_options[100];
int num_cc_options;

void init_main_menu_options(void (*ptr[])())
{
    create_menu_option(&menu_options[0], "New Game", ptr[0], 0);
    create_menu_option(&menu_options[1], "Load Game", ptr[1], 0);
    create_menu_option(&menu_options[2], "Quit", ptr[2], 0);
    num_main_menu_options = 3;
}

void create_menu_option(menu_option *m, char *name, void *ptr, int is_selected)
{
    strcpy(m->name, name);
    m->ptr = ptr;
    m->name_length = strlen(name);
    m->is_selected = is_selected;
}

// TODO: change this to be 'main menu option'
void select_menu_option(int num)
{
    menu_options[num].is_selected = 1;
}

// TODO: make resource path a const char*?

// ASCII art generated by tool by patorjk,
// http://patorjk.com/software/taag/
void render_main_menu(window_info *wi)
{
    // load main menu into buffer
    int w, h; // logo width and height
    char buffer[MAX_SIZE] = {'\0'};
    FILE *logo = fopen("../res/gfx/ui/logo", "r");
    if (logo != NULL)
    {
        if (fscanf(logo, "%d,%d", &w, &h) == 2)
        {
            // only executes if both width and height could be read
            int y = wi->center_rows - (wi->max_rows / 3) + (h / 2), x = wi->center_cols - (w / 2);
            //int y = 0, x = 0;
            char cur = fgetc(logo);
            while (cur != EOF)
            {
                if (cur == '\n')
                {
                    x = wi->center_cols - (w / 2); // reset x
                    move(++y, x);                  // add 1 to y, then move cursor
                }
                mvaddch(y, x++, cur); // add character, then iterate x
                cur = fgetc(logo);
            }
        }
        fclose(logo);
    }

    // print menu options
    for (int i = 0; i < num_main_menu_options; i++)
    {
        if (menu_options[i].is_selected)
            attron(COLOR_PAIR(6));
        mvaddstr(wi->center_rows + h + i, wi->center_cols - (menu_options[i].name_length / 2), menu_options[i].name);
        attroff(COLOR_PAIR(6)); // turn off color if used
    }
}

void process_menu_input(int input, int *selected_option)
{
    switch (input)
    {
    case KEY_UP:
        if (*selected_option == 0)
            *selected_option = 2;
        else
            (*selected_option)--;
        break;
    case KEY_DOWN:
        if (*selected_option == 2)
            *selected_option = 0;
        else
            (*selected_option)++;
        break;
    case 10: // enter
        menu_options[*selected_option].ptr();
        break;
    }
}

void init_character_creation_options(void) {
    create_menu_option(&character_creation_options[0], "Name: ", get_character_attribute, 0);
    create_menu_option(&character_creation_options[1], "Race: ", get_character_attribute, 0);
    create_menu_option(&character_creation_options[2], "Class: ", get_character_attribute, 0);
    num_cc_options = 3;
}

// maybe possible to toggle these on-off instead of systematically looping every game loop?
void select_cc_menu_option(int selected_field) {
    for (int i = 0; i < num_cc_options; i++) {
        character_creation_options[i].is_selected = 0;
    }
    character_creation_options[selected_field].is_selected = 1;
}

void render_character_creation_menu(window_info *wi, int selected_option, character *pc) {
    int initial_y = (wi->max_rows * 0.1), initial_x = (wi->max_cols * 0.1);
    int x = initial_x, y = initial_y;

    int vertical_padding = 3;

    box(stdscr, '|', '-');

    attron(A_BOLD);
    mvaddstr(y++, x, "Attributes:");
    attroff(A_BOLD);

    // update these test values to be actual character parameters
    print_status_bar(y++, x, "HP", 4, 5, 20);
    print_status_bar(y++, x, "SP", 2, 7, 15);
    print_status_bar(y++, x, "MP", 1, 20, 30);

    y += vertical_padding; // move 3 rows down

    for (int i = 0; i < num_cc_options; i++) {
        if (character_creation_options[i].is_selected)
            attron(COLOR_PAIR(6));
        mvaddstr(y++, x, character_creation_options[i].name);
        attroff(COLOR_PAIR(6));
    }

    y += vertical_padding;

    mvprintw(y++, x, "STR: %d", pc->strength);
    mvprintw(y++, x, "DEX: %d", pc->dexterity);
    mvprintw(y++, x, "CON: %d", pc->constitution);
    mvprintw(y++, x, "INT: %d", pc->intelligence);
    mvprintw(y++, x, "WIS: %d", pc->wisdom);
    mvprintw(y++, x, "CHA: %d", pc->charisma);

    char buf[MAX_SIZE] = { '\0' };
    //gets_window(wi, "name", buf);
}

void print_status_bar(int y, int x, char *name, short color_code, int actual, int nominal) {
    mvprintw(y, x, "%s: ", name);
    x += strlen(name) + 2; // move over x coordinates by name len + 2 (: and space)
    attron(COLOR_PAIR(color_code));

    double ratio = (double) actual / nominal;
    int red_nominal = 30, red_actual = red_nominal * ratio;
    
    for (int i = 0; i < red_nominal; i++) {
        if (i <= red_actual)
            mvprintw(y, x, "%lc", 0x2588);
        else
            mvprintw(y, x, "%lc", 0x2591);
        x++;
    }
    x += 1; // move one more space over
    attroff(COLOR_PAIR(color_code));
    mvprintw(y, x, "%d / %d", actual, nominal);
}

void render_dialogue_menu() {

}

void gets_window(window_info *wi, char *name, char *dest) {
    char buffer[MAX_SIZE] = { '\0' };
    char str[100];

    sprintf(str, "Enter a %s: ", name);

    window_info p_info = { (wi->max_rows/2), (wi->max_cols/2), (wi->max_rows/2)/2, (wi->max_cols/2)/2 };
    WINDOW *p = newwin(p_info.max_rows, p_info.max_cols, 
                        wi->center_rows - (p_info.center_rows), 
                        wi->center_cols - (p_info.center_cols));
    PANEL *p_panel = new_panel(p);

    box(p, '|', '-');

    update_panels();

    mvwaddstr(p, p_info.center_rows, p_info.center_cols - strlen(str), str);

    echo();

    wgetstr(p, buffer);

    doupdate();

    noecho();
}

// old code, to be removed... eventually :) (not using panels)
/*
    // fixed width and height? could modify to be variable
    window_info gets_info = { 20, 30, 10, 15 };
    WINDOW *gets_window = newwin(gets_info.max_rows, gets_info.max_cols, wi->center_cols - gets_info.center_rows, wi->center_rows - gets_info.center_rows);
    box(gets_window, '|', '-');
    mvwaddstr(gets_window, gets_info.center_rows, gets_info.center_cols - 11, "This is a test string");

    int initial_y = gets_info.center_rows, initial_x = gets_info.center_cols + 23;
    int y = initial_y, x = initial_x;

    refresh();

    redrawwin(gets_window);
    wrefresh(gets_window);

    char buffer[MAX_SIZE] = { '\0' };
    int input = -1, index = 0;
    //while (!strcmp(buffer, "")) {
        //mvwprintw(gets_window, 10, 10, buffer);
        wmove(gets_window, initial_y, initial_x);
        echo();
        
        wgetstr(gets_window, buffer);
    //}
    noecho();
    wclear(gets_window);
    delwin(gets_window);
    // return to dest
    strcpy(dest, buffer);
*/

int getint_window() {
    return 0;
}

int find_selected_cc_option(void) {
    for (int i = 0; i < num_cc_options; i++) {
        if (character_creation_options[i].is_selected)
            return i;
    }
    return -1;
}

void get_character_attribute(void) {
    // this function could be avoided with modified function ptrs or by a global selection value
    // but, it's only called when the player hits enter, so it should be okay
    int index = find_selected_cc_option();
    char return_buffer[MAX_SIZE];

    if (index != -1) {
        if (!strncmp(character_creation_options[index].name, "Name", 4)) {
            gets_window(&wi, "name", return_buffer);
            //strcpy()
        }
    }
}