#include "game/menu.h"

extern menu_option menu_options[100];
extern int num_main_menu_options;

menu_option character_creation_options[100];
int num_cc_options;

void init_main_menu_options(void (*ptr[])())
{
    create_menu_option(&menu_options[0], "New Game", ptr[0], 0);
    create_menu_option(&menu_options[1], "Load Game", ptr[1], 0);
    create_menu_option(&menu_options[2], "Quit", ptr[2], 0);
    num_main_menu_options = 3;
}

void create_menu_option(menu_option *m, char *name, void *ptr, int is_selected)
{
    strcpy(m->name, name);
    m->ptr = ptr;
    m->name_length = strlen(name);
    m->is_selected = is_selected;
}

// TODO: change this to be 'main menu option'
void select_menu_option(int num)
{
    menu_options[num].is_selected = 1;
}

// TODO: make resource path a const char*?

// ASCII art generated by tool by patorjk,
// http://patorjk.com/software/taag/
void render_main_menu(window_info *wi)
{
    // load main menu into buffer
    int w, h; // logo width and height
    char buffer[MAX_SIZE] = {'\0'};
    FILE *logo = fopen("../res/gfx/ui/logo", "r");
    if (logo != NULL)
    {
        if (fscanf(logo, "%d,%d", &w, &h) == 2)
        {
            // only executes if both width and height could be read
            int y = wi->center_rows - (wi->max_rows / 3) + (h / 2), x = wi->center_cols - (w / 2);
            //int y = 0, x = 0;
            char cur = fgetc(logo);
            while (cur != EOF)
            {
                if (cur == '\n')
                {
                    x = wi->center_cols - (w / 2); // reset x
                    move(++y, x);                  // add 1 to y, then move cursor
                }
                mvaddch(y, x++, cur); // add character, then iterate x
                cur = fgetc(logo);
            }
        }
        fclose(logo);
    }

    // print menu options
    for (int i = 0; i < num_main_menu_options; i++)
    {
        if (menu_options[i].is_selected)
            attron(COLOR_PAIR(6));
        mvaddstr(wi->center_rows + h + i, wi->center_cols - (menu_options[i].name_length / 2), menu_options[i].name);
        attroff(COLOR_PAIR(6)); // turn off color if used
    }
}

void process_menu_input(int input, int *selected_option)
{
    switch (input)
    {
    case KEY_UP:
        if (*selected_option == 0)
            *selected_option = 2;
        else
            (*selected_option)--;
        break;
    case KEY_DOWN:
        if (*selected_option == 2)
            *selected_option = 0;
        else
            (*selected_option)++;
        break;
    case 10: // enter
        menu_options[*selected_option].ptr();
        break;
    }
}

void init_character_creation_options(void) {
    create_menu_option(&character_creation_options[0], "Name: ", NULL, 0);
    create_menu_option(&character_creation_options[1], "Race: ", NULL, 0);
    create_menu_option(&character_creation_options[2], "Class: ", NULL, 0);
    num_cc_options = 3;
}

// maybe possible to toggle these on-off instead of systematically looping every game loop?
void select_cc_menu_option(int selected_field) {
    for (int i = 0; i < num_cc_options; i++) {
        character_creation_options[i].is_selected = 0;
    }
    character_creation_options[selected_field].is_selected = 1;
}

void render_character_creation_menu(window_info *wi, int selected_option, character *pc) {
    int initial_y = (wi->max_rows * 0.1), initial_x = (wi->max_cols * 0.1);
    int x = initial_x, y = initial_y;
    box(stdscr, '|', '-');

    for (int i = 0; i < num_cc_options; i++) {
        if (character_creation_options[i].is_selected)
            attron(COLOR_PAIR(6));
        mvaddstr(y + i, x, character_creation_options[i].name);
        attroff(COLOR_PAIR(6));
    }

}

void render_dialogue_menu() {

}